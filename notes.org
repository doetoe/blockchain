* The emphasis is on readability and simplicity, not on performance or other optimizations. For example

- When another miner generated a longer chain than you have, the full blockchain is downloaded from it, verified and then replaces the local one, rather than only downloading the required blocks, which would add the problem that the blockchain may get updated (even replaced) on the remote miner, etc.

- all unprocessed transactions are served rather than just some number

* To be done
- Inherit TransactionBlockChain from BlockChain to override the "mine" function. Maybe also the TransactionBlock. In mining, unprocessed transactions should be retrieved and bundled.
- node uses BlockChain.load (static). This is the only thing that has to change (in node.py) for different BlockChain classes.
- For transactions we may want to subclass or change Node (or rather some component it has, like a BlockValidator, or maybe the BlockChain itself) for another step to check for the validity of blocks. Moreover the node will have to assemble transaction bundles. Maybe another component: BlockDataCollector or similar. -> enough to just change the BlockChain.load
- configuration file for the different networks: minimal_blocks, transaction_blocks, contract_blocks, etc. Note that this loads the data as a BlockChain of the appropriate class. If nodes for different networks are connected with the same tracker, they will get mixed up: better that the tracker also be configured in the same way and only accepts node for the same network (minimal, transaction, contract,...)
- In node, tracker, mempool, better separate core functionality from network operations if possible (maybe in component classes)
- Wallet class, AddressBook etc - not important
- balance (user): allow incomplete address (prefix, as long as it is unique)
- blocks of transactions
- In validity check of blockchains containing transactions make sure that the balance is never negative. New function in transaction.py
- Good tests for web services
- fees and block reward go to miner_address

* Validity of a block
- correct format
- hash satisfies difficulty
- chain goes back to genesis block
- correct number of transactions 
- no duplicate transactions in whole chain
- correct block reward
- balance never below 0 for any address in the chain
- timestamp

* Robustness
- nodes and mempool continue working if the tracker is down.

* Operation
- Start the tracker. 
- Start one or more nodes. These will start mining and synchronizing. If the tracker goes down, they will keep mining (and trying to connect and broadcast/synchronize).
- Start the mempool
- Send transactions to the mempool
- Nodes pull transactions from the mempool to include in their blocks.
