* The emphasis is on readability and simplicity, not on performance or other optimizations. For example

- When another miner generated a longer chain than you have, the full blockchain is downloaded from it, verified and then replaces the local one, rather than only downloading the required blocks, which would add the problem that the blockchain may get updated (even replaced) on the remote miner, etc.

- all unprocessed transactions are served rather than just some number

* To be done
- Check mempool functionality in the extension of node in the file transactionnode.py
- like blockchain, synchronize transactions:
  - for each node, get unprocessed transactions (blockchain will synchronize soon enough to take care of differences in status), add to db (with block=NULL), set block index from local_blockchain (necessary?).
  - For the moment no effort is made to store the full historical mempool, processed transactions are already in the blockchain; alternatively could store transactions from the blockchain into the local mempool db, or broadcast and retrieve a full list of transactions.
- remove double-spend transactions (maybe). Alternatively they could float around until the balance is high enough.
- Inherit TransactionBlockChain from BlockChain to override the "mine" function. Maybe also the TransactionBlock. In mining, unprocessed transactions should be retrieved from all or some peers, or only local store, which is separately updated, and bundled.
- The TransactionBlockChain in its "mine" function has to have access to the mempool address or obtain unprocessed transactions in a different way. The "Node" right now is generic, which is good, but it could be that it needs to be different for a node processing transactions than for one validating basic blocks, and again for one that processes contracts. 
- Maybe integrate mempool in a general node (in some elegant, flexible, extensible and configurable way)
- In node, tracker, mempool, better separate core functionality from network operations if possible (maybe in component classes)
- Wallet class, AddressBook etc - not important
- balance (user): allow incomplete address (prefix, as long as it is unique)
- blocks of transactions
- In validity check of blockchains containing transactions make sure that the balance is never negative. New function in transaction.py
- Good tests for web services
- fees and block reward go to miner_address
- Instead of a mempool could have all nodes implement the services of the mempool, and synchronize the mempool between them
- deal with wrong nodes in an elegant way

* Validity of a block
- correct format
- hash satisfies difficulty
- chain goes back to genesis block
- correct number of transactions 
- no duplicate transactions in whole chain
- correct block reward
- balance never below 0 for any address in the chain
- timestamp

* Robustness
- nodes and mempool continue working if the tracker is down.

* Nodes
Each node serves as a full node, a miner and a tracker. When it is started, it tries to find other nodes first by iterating through a list TRACKER_ADDRESSES that is in the configuration file config.py. Alternatively a known node address can be specified.

It obtains a list of peers from each one of them, and registers with all running nodes.

It then starts both mining, and operating a full node (serving the full blockchain) as well as peer-discovery services. In the future it should also provide mempool services.

* Operation
- Start the tracker. 
- Start one or more nodes. These will start mining and synchronizing. If the tracker goes down, they will keep mining (and trying to connect and broadcast/synchronize).
- Start the mempool
- Send transactions to the mempool
- Nodes pull transactions from the mempool to include in their blocks.
